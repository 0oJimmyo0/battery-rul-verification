# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hFJxRG70ihzChNptvKTndwRIR-zG3Oy2
"""

# Install dependencies
!pip install torch torchvision torchaudio onnx sklearn pandas matplotlib
!pip install onnx onnxruntime
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader, random_split
import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import onnx

# Load dataset
file_path = "/content/Battery_dataset.csv"
df = pd.read_csv(file_path)
df = df.drop(columns=['battery_id'])

print("Columns:", df.columns.tolist())
print(df.head())

# Define feature and target columns
# Suppose target = Remaining Useful Life (RUL) or any numeric label column
target_col = 'RUL'
X = df.drop(columns=[target_col]).values
y = df[target_col].values

# Normalize features
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)

# Reshape for CNN input (CNN expects [batch, channel, seq_len])
# We treat features as a "1D signal" for simplicity
X_scaled = np.expand_dims(X_scaled, axis=1)

# Train-test split
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

# Create Dataset and DataLoader
class BatteryDataset(Dataset):
    def __init__(self, X, y):
        self.X = torch.tensor(X, dtype=torch.float32)
        self.y = torch.tensor(y, dtype=torch.float32)
    def __len__(self):
        return len(self.X)
    def __getitem__(self, idx):
        return self.X[idx], self.y[idx]

train_data = BatteryDataset(X_train, y_train)
test_data = BatteryDataset(X_test, y_test)
train_loader = DataLoader(train_data, batch_size=32, shuffle=True)
test_loader = DataLoader(test_data, batch_size=32)

# CNN model
class BatteryCNN(nn.Module):
    def __init__(self, input_len):
        super(BatteryCNN, self).__init__()
        self.conv1 = nn.Conv1d(1, 16, kernel_size=3, padding=1)
        self.conv2 = nn.Conv1d(16, 32, kernel_size=3, padding=1)
        self.pool = nn.MaxPool1d(2)
        self.fc1 = nn.Linear((input_len // 2) * 32, 64)
        self.fc2 = nn.Linear(64, 1)
        self.relu = nn.ReLU()
        self.dropout = nn.Dropout(0.2)

    def forward(self, x):
        x = self.relu(self.conv1(x))
        x = self.pool(self.relu(self.conv2(x)))
        x = x.view(x.size(0), -1)
        x = self.dropout(self.relu(self.fc1(x)))
        return self.fc2(x)

model = BatteryCNN(input_len=X_scaled.shape[2])
print(model)

# Train
criterion = nn.MSELoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)
epochs = 30
train_losses = []

for epoch in range(epochs):
    model.train()
    running_loss = 0.0
    for inputs, targets in train_loader:
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs.squeeze(), targets)
        loss.backward()
        optimizer.step()
        running_loss += loss.item()
    train_losses.append(running_loss / len(train_loader))
    print(f"Epoch [{epoch+1}/{epochs}] Loss: {train_losses[-1]:.4f}")

# Evaluate with metrics and plot
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import numpy as np
import matplotlib.pyplot as plt

model.eval()
with torch.no_grad():
    preds, actuals = [], []
    for inputs, targets in test_loader:
        outputs = model(inputs)
        preds.extend(outputs.squeeze().tolist())
        actuals.extend(targets.tolist())

# Convert to numpy
preds = np.array(preds)
actuals = np.array(actuals)

# Calculate metrics
rmse = np.sqrt(mean_squared_error(actuals, preds))
mae = mean_absolute_error(actuals, preds)
r2 = r2_score(actuals, preds)

print(f"RMSE: {rmse:.4f}")
print(f"MAE: {mae:.4f}")
print(f"R²: {r2:.4f}")

# Plot sample predictions
plt.figure(figsize=(8,4))
plt.plot(actuals[:100], label='True RUL', linewidth=2)
plt.plot(preds[:100], label='Predicted RUL', linewidth=2, linestyle='--')
plt.xlabel("Sample Index")
plt.ylabel("RUL")
plt.title("RUL Prediction (CNN model)")
plt.legend()
plt.grid(True)
plt.show()


# Export to ONNX for verification
dummy_input = torch.randn(1, 1, X_scaled.shape[2])
onnx_path = "/content/battery_cnn.onnx"
torch.onnx.export(model, dummy_input, onnx_path, input_names=["input"], output_names=["output"])
print(f"✅ Model exported to: {onnx_path}")